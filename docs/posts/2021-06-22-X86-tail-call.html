<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>τ - Tail Call</title>
	<link rel="stylesheet" href="../css/default.css" />
	<link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/github.min.css">
	<link rel="icon" href="../favicon.svg">

</head>

<body>
	<header>
		<div class="logo">
			<a href="../"> τ </a>
		</div>
		<nav>
			<a href="../">Home</a>
			<a href="../archive.html">Archive</a>
		</nav>
	</header>

	<main role="main">
		<h1>Tail Call</h1>
		<article>
	<div class="light">
		Posted on June 22, 2021
		
		by τ
		
	</div>
	<section>
		<h2 id="x86-tail-call-汇编">X86 Tail Call 汇编</h2>
<p>阶乘的 C 语言实现（尾优化版本）：</p>
<pre class="c"><code>// fac.c
int __attribute__((noinline)) fac_iter(int n, int acc) {
  if (n &lt;= 1)
    return acc;
  else
    return fac_iter(n - 1, acc * n);
}

int fac(int n) { return fac_iter(n, 1); }</code></pre>
<p>代码中的 <code>__attribute__((noinline))</code> 是告诉编译器在 <code>fac</code> 中调用 <code>fac_iter</code> 时不要内联函数，以便观察 tail call 对应的汇编代码。</p>
<p>clang 编译选项：</p>
<ul>
<li><code>-mno-sse</code>: 关闭 SIMD 优化</li>
<li><code>-fno-asynchronous-unwind-tables</code>: 关闭 <code>.cfi</code></li>
</ul>
<h3 id="-o0"><code>-O0</code></h3>
<p><code>clang -c -mno-sse -fno-asynchronous-unwind-tables -S -O0 fac.c</code> 的结果没有尾优化，所有的函数调用都是使用 <code>callq</code>：</p>
<pre class="assembly"><code>_fac_iter:                              ## @fac_iter
    movl    %esi, %eax
    cmpl    $2, %edi
    jl    LBB0_2
    pushq    %rbp
    movq    %rsp, %rbp
    imull    %edi, %eax
    decl    %edi
    movl    %eax, %esi
    callq    _fac_iter
    popq    %rbp
LBB0_2:
    retq

_fac:                                   ## @fac
    pushq    %rbp
    movq    %rsp, %rbp
    movl    $1, %esi
    callq    _fac_iter
    popq    %rbp
    retq</code></pre>
<h3 id="-o2"><code>-O2</code></h3>
<p><code>clang -c -mno-sse -fno-asynchronous-unwind-tables -S -O2 fac.c</code> 的结果已有尾优化：</p>
<pre class="assembly"><code>_fac_iter:                              ## @fac_iter
    pushq    %rbp
    movq    %rsp, %rbp
    movq    %rsi, %rax
    cmpq    $2, %rdi
    jl    LBB0_2
LBB0_1:                                 ## =&gt;This Inner Loop Header: Depth=1
    imulq    %rdi, %rax
    leaq    -1(%rdi), %rcx
    cmpq    $2, %rdi
    movq    %rcx, %rdi
    jg    LBB0_1
LBB0_2:
    popq    %rbp
    retq

_fac:                                   ## @fac
    pushq    %rbp
    movq    %rsp, %rbp
    movl    $1, %esi
    popq    %rbp
    jmp    _fac_iter                       ## TAILCALL</code></pre>
<p>在 <code>fac_iter</code> 对应的汇编代码中，递归函数调用被直接优化成了循环的实现。</p>
<p>而在 <code>fac</code> 函数中，我们可以看到调用 <code>fac_iter</code> 的地方使用的是 <code>jmp</code>，而不是 <code>callq</code>。<code>fac</code> 中首先把 <code>%esi</code> （也就是 <code>fac_iter</code> 的第二个参数）设置为 1，然后直接 jump 到 <code>fac_iter</code> 执行。这也意味着，<code>fac_iter</code> 函数栈帧之上的栈帧是调用 <code>fac</code> 的函数，而不是 <code>fac</code>。<code>fac_iter</code> 函数返回时，直接返回调用 <code>fac</code> 函数的地方，而不是 <code>fac</code> 内部。</p>
<p>Tail call 优化的好处在于可以节省栈空间，也为较深的调用链和尾递归提供了可能。</p>
<h3 id="tail-call-优化的递归调用">Tail Call 优化的递归调用</h3>
<p>值得注意的是，在上面的 <code>fac_iter</code> 的汇编中，尾递归并没有使用 tail call 的优化，而是直接优化成了函数内部的循环。事实上我们可以把 tail recursion 看做一种特殊的 tail call，它可以被优化成函数内部的循环，也可以使用一般的 tail call 优化。下面的代码是我从 <code>-O2</code> 的汇编代码修改而来，把 <code>fac_iter</code> 中的循环修改为 tail call：</p>
<pre class="diff-assembly"><code>_fac_iter:                              ## @fac_iter
    pushq    %rbp
    movq    %rsp, %rbp
    movq    %rsi, %rax
    cmpq    $2, %rdi
    jl    LBB0_2
+    imulq    %rdi, %rsi     ## %rsi *= %rdi (acc * n)
+    leaq    -1(%rdi), %rdi  ## %rdi -= 1    (n-1)
+    popq    %rbp
+    jmp     _fac_iter
LBB0_2:
    popq    %rbp
    retq
                                        ## -- End function
_fac:                                   ## @fac
    pushq    %rbp
    movq    %rsp, %rbp
    movl    $1, %esi
    popq    %rbp
    jmp    _fac_iter                       ## TAILCALL</code></pre>
<p>如果简单分析汇编代码，我们可以发现，tail call 的版本不会因为递归调用产生新的栈帧，大致等价于循环。但是相比与普通的循环版本，tail call 版本中多了许多的对栈帧指针 <code>%rbp</code> 的操作。</p>
<h3 id="性能比较">性能比较</h3>
<p>我们把上面三段代码分别编译并链接相同的测试代码，得到的程序分别称为 <code>fac-O0</code>、<code>fac-O2</code>、<code>fac-tail-call</code>。我使用的测试环境是 MacBook Pro (16-inch, 2019) Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz。测试结果如下（macrosconds）：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;"><code>fac-O0</code> 时间</th>
<th style="text-align: left;"><code>fac-O2</code> 时间</th>
<th><code>fac-tail-call</code> 时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">5!</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">5</td>
<td>4</td>
</tr>
<tr class="even">
<td style="text-align: left;">10!</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">5</td>
<td>5</td>
</tr>
<tr class="odd">
<td style="text-align: left;">100000!</td>
<td style="text-align: left;">2,703</td>
<td style="text-align: left;">117</td>
<td>142</td>
</tr>
<tr class="even">
<td style="text-align: left;">1000000!</td>
<td style="text-align: left;">29,670</td>
<td style="text-align: left;">1,032</td>
<td>1,385</td>
</tr>
<tr class="odd">
<td style="text-align: left;">10000000!</td>
<td style="text-align: left;">stack overflow</td>
<td style="text-align: left;">10,095</td>
<td>13,650</td>
</tr>
<tr class="even">
<td style="text-align: left;">100000000!</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">84,169</td>
<td>103,362</td>
</tr>
</tbody>
</table>
<p>可以看到，<code>fac-O2</code> 和 <code>fac-tail-call</code> 的性能相差不是特别明显，<code>fac-O2</code> 所用的时间大概是 <code>fac-tail-call</code> 的 80% 左右。</p>
<h3 id="完整源码">完整源码</h3>
<script src="https://gist.github.com/yangtau/8a3046562aeb1567f934e238d49c275a.js"></script>
	</section>
</article>

	</main>

	<footer>
		Site proudly generated by
		<a href="http://jaspervdj.be/hakyll">Hakyll</a>
	</footer>
</body>

<script src="//unpkg.com/@highlightjs/cdn-assets@11.6.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

</html>
