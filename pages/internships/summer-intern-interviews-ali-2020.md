---
title: 暑期实习面试：阿里
date: 2020-04-24
template: post-code
author: τ
hide: true
---

在收到腾讯的 offer 之后，懒惰的我就不想面试了。于是华为的笔试题完全没有做，直接推掉百度的面试。阿里的笔试也没有认真做，一道题都没有写出来😅。然而，笔试完的当天下午就收到阿里的来电。和面试官简单地聊了聊，主要聊了操作系统，感觉表现得也很一般。过了很长一段时间都没有收到什么消息，我以为多半被拒了。然后在某个『专心』上着网课的上午，突然收到了阿里面试官的来电，说他是编译器部门的，约我面试。

我最初投的岗位是 C/C++ 开发工程师。我再去招聘官网看时，岗位已经变成了基础平台研发工程师，C/C++ 开发工程师的状态变成了 Rejected。在我的记忆中，我好像没有改过岗位，我只能猜想是面试官看到我简历上做过编译器的工作，所以把我捞起来了 :)。

不管怎样，我还是非常开心，因为我特别想做编译相关的工作。

## 阿里一面

一面聊了项目，编译原理，还有一些别的基础知识。

自我介绍完了之后，面试官问我学习语言设计过程中有感到惊艳的时刻吗。我提到了 Rust 当中 *if-else* 作为表达式，将函数式编程与过程式编程两种范式统一在同一种语法中。因为面试官不太了解 Rust，我就给他详细解释了这个设计。由于是电话面试，不能展示代码，感到自己语言的匮乏。

接着开始聊我做过的项目，Hedgehog。面试官居然打开了我的 blog，对着我画的图问我一些编译的知识。具体细节已经忘记了，大体上提到了这些知识点：

- 语法树的生成、求值。面试官专门对着函数生成的语法树发问。
- 语法树翻译成 IR。面试官让我把 blog 中一张语法树的图翻译成三地址码。
- 编译优化。我没有学过这部分知识，老实承认了。面试官就让我凭自己的想法讲了一下优化。我提到了常量折叠和删除不可到达代码。面试官继续让我想怎么对代码建立一个数据结构以便去优化。因为完全不懂，我就凭自己的想法瞎说了一大堆。然后面试官耐心地给我讲解了什么是基本块，怎样对代码建模等等。
- Environment（这是我在 Hedgehog 中实现 scope 的方法）。面试官就这个问了栈和堆的一些问题，然后提到了 ELF 文件和 malloc。因为我手写过 ELF 的加载器和 malloc 所以回答的还不错。

面试官针对我不太会 C++ 聊了很多。为什么不熟 C++？有没有想过在项目中用它？等等。一副如果我会 C++，他就可以让我通过的样子😂。

然后我问他，他们团队具体做的工作。他说，他们主要在做后端优化的工作，如 GCC，LLVM。也会有一些前端的工作，例如实现 C++ 新标准里的协程（果然是大厂，都是做前沿工作的，xmsl）。

最后，他非常耐心地给了我一些学习编译的建议。

## 阿里二面

二面主要问了一些基础问题，并表演手撕代码。

同样，面试官先让我自我介绍一下。我把上次准备的自我介绍又念了一遍 🤣。不同的是，这次面试官每听我说完一段都会『嗯』一声作为回应。这不是肯定的回应，当然也不否定，语气平淡得如白开水一样。作为被面试者，我听到这样的回应感到挺舒服的。如果没有半点回应，就像在对着深渊喊话一样，永远没有回声，也不知道自己是否说得恰当。

面试官了解到我学习过不少语言的设计和阅读过很多代码后，让我随便说说感想。这个问题挺可以回答得挺广泛的，一面的面试官也有类似的问题。我猜想，阿里的面试官希望通过这样的问题了解被面试者的技能点，以便在被面试者熟悉的领域深入考察被试者。

我当时有点傻，回答了一个和上次不一样的感想（如果重复上一次的可能更加游刃有余一些）。我提到了 Ruby 中使用 Mixin 这样的技术去规避 C++ 中多继承产生的问题。其实我对这个问题的思考并不深入。面试官马上抓住了问题的关键，继续发问：多继承有什么问题，Mixin 怎样去规避它？我提到了多继承可能产生菱形继承、父类方法重名、编译器实现复杂这些问题。Mixin 将一组方法集成到一个 module，然后在需要的类中 include 相应的 module。还好，面试官没有再继续深问下去，再问，我就只能回答不懂了。这也给了我一个教训：在学习中，对于一些值得深入去思考的问题，一定要深入下去，不能浅尝辄止。例如这里的 Mixin 和多继承，就应该了解他们在编译器的层面的实现。这个问题应该写一篇文章去好好总结一下嘛（疯狂挖坑）。

然后我又聊了一下 Rust 用显式的 ownership 管理和 borrow 的机制去避免使用 GC。面试官问了一下 Rust 具体是怎么回收内存的，以及引用计数的算法。因为我没有看过 Rust 的实现，只是在学习它的使用，就只能从它的限制来猜测它的实现。

之后随便问了一下项目，就开始编程。题目非常简单：写一个函数，删除单链表中的与给定变量相同的节点，并返回删除节点的值。链表储存什么值可以自由发挥（听到这句话的时候我就想写一个 `void*` 作为储存值，然后用函数指针判定值是否相等的链表。但是怂了，没有写）。

我的第一版实现：

```c
struct list {
  int val;  
  struct list *next;
};

/**list_remove: version 1.0 
 * return 0 if `v` is found, -1 otherwise
 */
int list_remove(struct list *head, int v, int *res) {
  // `head` is a sentinel node which contains nothing
  struct list *pre = head;
  struct list *lp = NULL;

  if (pre != NULL)
    lp = pre->next;

  while (lp != NULL) {
    if (lp->val == v) {
      *res = v;
      pre->next = lp->next;
      free(lp);
      return 0;
    }
    pre = lp;
    lp = lp->next;
  }
  return -1;
}
```

第一版的实现中，我假定这个单链表是一个头节点为空的链表。面试官说不要这个假设，于是写了下面这个用指针的指针实现的版本。如果看过 Linus 在 TED 的演讲，就应该知道另一个非常优雅的实现。但是我还是怂了，不敢冒险，写了个『平庸』的版本。

```c

struct list {
  int val;
  struct list *next;
};

/**list_remove: version 1.0
 * return 0 if `v` is found, -1 otherwise
 */
int list_remove(struct list **head, int v, int *res) {
  struct list *lp = *head;

  if (lp == NULL)
    return -1;
  if (lp->val == v) {
    *head = lp->next;
    free(lp);
    *res = v;
    return 0;
  }

  struct list *pre = lp;
  lp = lp->next;
  while (lp != NULL) {
    if (lp->val == v) {
      *res = v;
      pre->next = lp->next;
      free(lp);
      return 0;
    }
    pre = lp;
    lp = lp->next;
  }
  return -1;
}
```

然后面试官说能改进吗，我说时间复杂性上是没有办法改进的，不过可以利用指针的指针不需对 `head` 的特殊处理（即 Linus 的实现），并且老实地承认了我可能写不出来（太不自信了）。

编程结束之后又聊了一些 OS，PL 方面的知识。阿里的面试官真是非常贴心，专门问我对什么比较熟悉，并且在我熟悉的方向问下去。但是问题非常深入，能够考察被试者是否真的掌握了某个知识点，以及掌握的程度。

<!--
我们先聊了一下虚拟内存（CSAPP 上对其三点总结非常精炼），然后又提到了 page fault。这时，我提到了在内核编程中，可以适当减少函数内联以减少内核大小，从而减少 page fault。话题就转向了内联为什么能够加快代码的执行效率，我提到了 CPU 能够更快地执行顺序代码和编译器的优化两方面。
-->
## 总结

阿里的面试官总体来说都很好，他们本身在 OS，编译器方面的知识就很全面且深入（怎么一副我在面试面试官的样子 😂）。他们提问的时候会尽量在我熟悉的、学过的地方考察我。不像某跳动的面试官，疯狂抛出一堆很厉害的技术的名字，问我懂不懂。『不懂』。然后就面试结束，得出这个被试者太菜的结论，拒了。

在我看来，对于一个本科生来说，关键的不是懂多少听起来很酷的技术名词，而是对某些的技术理解得有多深刻。不仅要知道某个技术是什么、怎么用，为什么要用它和怎么在更加底层的层面去实现它也非常重要。阿里的面试官在这点上做得很好，会在我熟悉的领域，不停地深挖，看我对这个知识点到底理解得有多深入。

说一下我在面试中表现不好的地方，一些教训吧：

- 不够自信。二面的编程测试，我其实可以写一个更加优雅、更能展现我能力的实现的。但是我太不自信了，害怕自己写不好，其实面试结束后几分钟就写出来了。

```c
struct list {
  struct list *next;
  void *p;
};

/**list_remove: remove `n` in the list if `cmp(n->p, v) == 0`
 * version 3.0
 * @RETURN: 0 if `v` is found, -1 otherwise
 * @res: return `p` in the removed node
 */
int list_remove(struct list **head, void *v, void **res,
                int (*cmp)(void *, void *)) {
  while (*head != NULL) {
    struct list *t = *head;
    if (cmp(t->p, v) == 0) {
      *res = t->p;
      *head = t->next; // delete the node in `*head` (`t`)
      free(t);
      return 0;
    }
    head = &(*head)->next; // the precedence of `->` is higher than `&` and `*`
  }

  return -1;
}
```
   
- 表达不好。我对某些问题可能理解得还不错，但是表达的时候容易说偏，用一些不准确的表达。

- 平时学习还是不够深入。对很多问题，我在平时学习的时候应该更加深刻地去理解，但是懒惰的我常常浅尝辄止了。于是常常浮于表面，没深入核心。

再总结一下面试的经验吧（也不算经验，就是很个人的想法）：

- 诚恳谦逊。不懂就老实说不懂，好的面试官经验、知识非常丰富，装懂也没有用。
- 善于引导话题。例如面试官提到 Go 的 Goroutine。不懂就老实说，但是可以联想到它和 Actor 并发模型很相似。如果了解 Actor 并发模型的话，可以把话题引导到自己熟悉的知识上去。要学会在短暂的面试中主动展示自己，不要完全依靠面试官的主动发问，尤其是在面试官比较坑的时候。
- 自信一点。上面已经提到了我的教训。
- 实实在在的能力是一切的前提。如果基础不扎实，代码能力也一般，那就少点焦虑，静下心去学习吧。

阿里大概是我暑期实习最后一个面试了，现在并不知道结果怎么样，但是的确让我学到了不少东西。面试官扎实的知识和和善的态度也让我非常向往去大厂工作 😁。希望大家都能得到想要的 offer 吧。

