<!DOCTYPE html>
<html>

<head> 

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>CSAPP Cache Lab 缓存实验</title>
<link rel="stylesheet" href="style-mf.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/styles/atom-one-light.min.css">

<head>

<body>


    <div class="content">
    
    <p>
        <a href="/">Home</a>
    </p>
    
    <h1>CSAPP Cache Lab 缓存实验</h1>
    <div class="light">作者：τ</div>
    <div class="light">日期：2019-08-21</div>

    
    <p>我最开始觉得这个实验就是写一个缓存模拟器和利用缓存优化代码，应该挺简单的。结果发现，这个实验设计得真的很好，并没用那么简单。所以，赶紧写篇文章记录自己的实验。</p>
<p>Part A是写一个缓存的模拟器，相对而言比较简单，我这里就不记录Part A了。Part B是根据缓存的特性来优化矩阵转置的代码，这应该是这个实验最有意思的一部分，看似很简单，但是要优化到满分难道不小。并且，Part B中对缓存是否命中的定量分析也是很有趣的。</p>
<div class="toc">
<ul>
<li><a href="#_1">实验介绍</a></li>
<li><a href="#_2">思路：分块</a></li>
<li><a href="#32-x-32">32 x 32</a><ul>
<li><a href="#_3">普通分块</a><ul>
<li><a href="#_4">实现</a></li>
<li><a href="#_5">结果分析</a></li>
</ul>
</li>
<li><a href="#_6">缓存分块</a><ul>
<li><a href="#_7">实现</a></li>
<li><a href="#_8">结果分析</a></li>
</ul>
</li>
<li><a href="#_9">对角线优先复制</a><ul>
<li><a href="#_10">实现</a></li>
<li><a href="#_11">结果分析</a></li>
</ul>
</li>
<li><a href="#_12">先复制后转置</a><ul>
<li><a href="#_13">实现</a></li>
<li><a href="#_14">结果分析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#64-x-64">64 x 64</a><ul>
<li><a href="#_15">实现</a></li>
<li><a href="#_16">结果分析</a></li>
</ul>
</li>
<li><a href="#61-x-67">61 x 67</a></li>
<li><a href="#_17">总结</a></li>
</ul>
</div>
<h2 id="_1">实验介绍</h2>
<p>Part B 是根据缓存的特性优化矩阵转置，目标是miss次数尽量的小。</p>
<p>输入是三个不同的固定大小的矩阵，矩阵分别为：</p>
<ul>
<li>32 x 32，miss次数小于300满分。</li>
<li>64 x 64，miss次数小于1300满分。</li>
<li>61 x 67， miss次数小于2000满分。</li>
</ul>
<p>可以根据矩阵的大小做特定的优化。实验还有如下限制：</p>
<ul>
<li>最多12个<code>int</code>类型的本地变量，不能用其他整数类型来储存<code>int</code>类型的值。</li>
<li>不能修改<code>A</code>矩阵的内容，<code>B</code>矩阵可随意。</li>
<li>不能用<code>malloc</code>类函数。</li>
</ul>
<p>用来测试miss的是Part A的缓存模拟器，缓存的参数为<code>s=5, E=1, b=5</code>， 即共有32个set， 每个set有一个cache line(直接映射), 每个块的大小为32 bytes。</p>
<h2 id="_2">思路：分块</h2>
<p>CSAPP书上有介绍矩阵乘法的优化，里面就用到了分块的思路。我们这里也要使用分块的思路来优化矩阵转置。那么为什么分块会对缓存更加友好呢？</p>
<p>我们可以先看一下最简单的转置实现：</p>
<pre><code class="C">void trans(int M, int N, int A[N][M], int B[M][N]) {
    int i, j, tmp;
    for (i = 0; i &lt; N; i++) {
        for (j = 0; j &lt; M; j++) {
            tmp = A[i][j];
            B[j][i] = tmp;
        }
    }
}
</code></pre>

<p>这里我们会按行优先读取<code>A</code>矩阵，然后一列一列地写入<code>B</code>矩阵。在C语言，多维数组在内存中是逐行逐行地排列的。也就是说，每一行的内容是在同一块连续内存中的，并且相邻行的内存块的地址是连续的。缓存每次会从内存中加载固定大小的内存块。例如，程序在从内存读<code>A[0][0]</code>的时候，除了<code>A[0][0]</code>被加载到缓存中，它之后的<code>A[0][1], A[0][2]...</code>也可能被加载进缓存。</p>
<p>这里程序逐行地读取<code>A</code>矩阵的内容对缓存是优好的。但是内容写入<code>B</code>矩阵的时候是一列一列地写入，在列上相邻的元素很有可能不在一个内存块上，这样每次写入都不能命中缓存，需要从内存中加载待写入的部分。缓存的大小是很有限的，一列写完后，再返回第一行的下一列的时候原来在缓存中的内容可能也被替换了，又要重新再从内存中读。所以，最坏的情况下，每次写入内容到<code>B</code>矩阵都需要读内存。</p>
<pre><code>矩阵B按列写的过程， * 表示内容加载到了缓存中。
假设每个缓存块的大小为4个int的大小，B矩阵每相隔四行的行地址在缓存中的index会重复一次。
也就是说第一行的前四个元素和第五行的前四个元素会占据相同的缓存块。
   |                          |                           | 
   V                          V                           V
  +-+-+-+-+-+-+-+-+          +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+      
  |*|*|*|*| | | | |          | | | | | | | | |         |*|*|*|*| | | | |     
  +-+-+-+-+-+-+-+-+          +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+     
  |*|*|*|*| | | | |          | | | | | | | | |         |*|*|*|*| | | | |     
  +-+-+-+-+-+-+-+-+          +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+     
  |*|*|*|*| | | | |          | | | | | | | | |         |*|*|*|*| | | | |     
  +-+-+-+-+-+-+-+-+          +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+     
  |*|*|*|*| | | | |   =&gt;     | | | | | | | | |   =&gt;    |*|*|*|*| | | | |   
  +-+-+-+-+-+-+-+-+          +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+      
  | | | | | | | | |          |*|*|*|*| | | | |         | | | | | | | | |      
  +-+-+-+-+-+-+-+-+          +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+      
  | | | | | | | | |          |*|*|*|*| | | | |         | | | | | | | | |      
  +-+-+-+-+-+-+-+-+          +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+      
  | | | | | | | | |          |*|*|*|*| | | | |         | | | | | | | | |      
  +-+-+-+-+-+-+-+-+          +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+      
  | | | | | | | | |          |*|*|*|*| | | | |         | | | | | | | | |      
  +-+-+-+-+-+-+-+-+          +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+      
        (1)                        (2)                         (3)

(1) 写入第一列的前四行
(2) 写入第一列后四行时，前四行缓存的内容被替换
(3) 写入第二列的时候，又需要重新从内存中读前四行的内容
</code></pre>

<p>分块的思路就是我们限制每次写入<code>B</code>矩阵的行数，充分利用<code>B</code>矩阵在缓存中的部分。比如在上面的例子中，我们可以把分块限制为<code>4 x 4</code>的大小，充分利用已经加载到缓存中的内容。</p>
<pre><code>   |                          | 
   V                          V
  +-+-+-+-+-+-+-+-+        +-+-+-+-+-+-+-+-+      
  |*|*|*|*| | | | |        |*|*|*|*| | | | |     
  +-+-+-+-+-+-+-+-+        +-+-+-+-+-+-+-+-+     
  |*|*|*|*| | | | |        |*|*|*|*| | | | |     
  +-+-+-+-+-+-+-+-+        +-+-+-+-+-+-+-+-+     
  |*|*|*|*| | | | |        |*|*|*|*| | | | |     
  +-+-+-+-+-+-+-+-+        +-+-+-+-+-+-+-+-+     
  |*|*|*|*| | | | |   =&gt;   |*|*|*|*| | | | |   
  +-+-+-+-+-+-+-+-+        +-+-+-+-+-+-+-+-+      
  | | | | | | | | |        | | | | | | | | |      
  +-+-+-+-+-+-+-+-+        +-+-+-+-+-+-+-+-+      
  | | | | | | | | |        | | | | | | | | |      
  +-+-+-+-+-+-+-+-+        +-+-+-+-+-+-+-+-+      
  | | | | | | | | |        | | | | | | | | |      
  +-+-+-+-+-+-+-+-+        +-+-+-+-+-+-+-+-+      
  | | | | | | | | |        | | | | | | | | |      
  +-+-+-+-+-+-+-+-+        +-+-+-+-+-+-+-+-+      
        (1)                      (2)

(1) 先写入第一列的前四行，前四列的前四行都被加载到缓存中
(2) 再写入第二列的前四行，不需要再从内存中重新加载

</code></pre>

<p><code>A</code>矩阵也会以同样的方式按照一个块读取内容，同样对缓存是友好的。</p>
<p>总的来说，分块解决的是在矩阵转置过程中，两个矩阵的内存的访问顺序不同导致的缓存不友好的问题，减少了同一个矩阵内部缓存块相互替换的问题。</p>
<h2 id="32-x-32">32 x 32</h2>
<p>缓存块的大小为32 bytes，可以存8个<code>int</code>类型的数据，那么矩阵每行需要4个缓存块。缓存块的总数是32个，那么相隔8行矩阵的行开始的缓存块的<code>index</code>就会重复。</p>
<pre><code> 矩阵中缓存块`index`的分布：
    +--+--+--+--+
 0  | 0| 1| 2| 3|
    +--+--+--+--+
 1  | 4| 5| 6| 7|
    +--+--+--+--+
 2  | 8| 9|10|11|
    +--+--+--+--+
 3  |12|13|14|15|
    +--+--+--+--+
 4  |16|17|18|19|
    +--+--+--+--+
 5  |20|21|22|23|
    +--+--+--+--+
 6  |24|25|26|27|
    +--+--+--+--+
 7  |28|29|30|31|
    +--+--+--+--+
 8  | 0| 1| 2| 3|
    +--+--+--+--+
    ...

每一个小格子表示一个缓存块，格子中的数字是缓存块的index。
可以看到第0行和第8行缓存块的index是重复的。
</code></pre>

<p>为了使得同一个矩阵的在缓存中的内容不被相互替换，我们可以把分块的大小设为<code>8 x 8</code>。</p>
<h3 id="_3">普通分块</h3>
<h4 id="_4">实现</h4>
<p>我们先直接按照<code>8 x 8</code>分块实现一个矩阵的转置：</p>
<pre><code class="C">for (i = 0; i &lt; N; i += 8) {
    for (j = 0; j &lt; M; j += 8) {
        // 分块
        for (k = i; k &lt; min(i + 8, N); k++) {
            for (s = j; s &lt; min(j + 8, M); s++) {
                B[s][k] = A[k][s];
            }
        }
    }
}
</code></pre>

<h4 id="_5">结果分析</h4>
<p>在正式测试miss之前，我们先人工分析一下miss的次数：</p>
<p>每个分块的大小为<code>8 x 8</code>， 所以每个块的miss次数是<code>8</code>。每个矩阵有16个分块，有两个矩阵，所以总的miss次数就是<code>8*16*2=256</code>。</p>
<p>测试一下：</p>
<pre><code class="bash">$ ./test-trans -M 32 -N 32
Function 2 (4 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 2 (8x8 block): hits:1710, misses:343, evictions:311
</code></pre>

<p>测试结果miss的次数是<code>343</code>，和我们的分析相差很大，也没有达到满分的要求。</p>
<p>我们前面的分析漏掉了什么呢？我了调整代码，输出了<code>A</code>，<code>B</code>矩阵在内存中的地址：</p>
<pre><code>A:55ed51a670a0, B:55ed51aa70a0
</code></pre>

<p>我们可以看到<code>A</code>，<code>B</code>的地址最后16 bits都是相同的，而缓存的<code>index</code>是由倒数5到10的bit组成，所以<code>A</code>，<code>B</code>在缓存中的内容会冲突。因为<code>A</code>， <code>B</code>是互为转置，所以冲突<code>A</code>， <code>B</code>只会发生在矩阵对角线上的块。</p>
<p>我们来分析一下对角线上缓存块的冲突。我用<code>A[n]</code>表示第n的缓存块， <code>A[n][m]</code>表示第n个缓存块上的第m个元素。</p>
<p>首先<code>A</code>， <code>B</code>固定的miss为16。</p>
<p>在对角线元素复制时<code>B[m][m] = A[m][m]</code>，  会发生<code>A[m]</code>，<code>B[m]</code>之间的冲突。复制前， <code>A[m]</code>开始在缓存中，<code>B[m]</code>不在。 复制时， <code>A[m]</code>被<code>B[m]</code>取代。 下一个开始复制<code>A[m]</code>又被重新加载进入缓存取代<code>B[m]</code>。这样就会产生2次多余的miss。</p>
<p>最后一行和第一行情况有些不一样： 第一行<code>B[m]</code>被加载到缓存中是第一次，应该算在那16次中， 但是同样会发生<code>A[0]</code>的重新加载， 所以额外产生的miss次数为1。 最后一行<code>A[7]</code>被取代， 但是复制已经完成，不需要再将<code>A[7]</code>加载进内存，所以额外的miss也为1。 </p>
<p><code>B[m]</code>被<code>A[m]</code>取代， 在下一行<code>A[m+1]</code>复制时需要重新加载<code>B[m]</code>进入缓存(第一行除外)， 所以会除了第一行每行又多了一次miss。 所有总的额外的miss的数目为<code>2*6+1*2+7=21</code>。
加上固定的miss次数， 对角块上的总的miss次数为<code>37</code>次。</p>
<p>具体的过程：</p>
<pre><code>缓存中的内容:
+-----------------------+-------------------+
| opt                   |  cache            |
+-----------------------+-------------------+
|before B[0][0]=tmp     | A[0]              |---+
+-----------------------+-------------------+   |
|after B[0][0]=tmp      | B[0]              |   |    
+-----------------------+-------------------+   |    A的第一行复制到B的第一列.
|after tmp=A[0][1]      | A[0]              |   |    最终缓存中剩下A[0], B[1]...B[7].
+-----------------------+-------------------+   +--&gt; A[0]被两次加载进入内存, 
|after B[1][0]=tmp      | A[0] B[1]         |   |    总的miss次数是10.               
+-----------------------+-------------------+   |    
|...                    |                   |   |    
+-----------------------+-------------------+   |
|after B[7][0]=tmp      | A[0] B[1..7]      |---+
+-----------------------+-------------------+
|after B[0][1]=tmp      | A[1] B[0] B[2..7] |---+
+-----------------------+-------------------+   |    A的第二行复制到B的的二列.
|after B[1][1]=tmp      | B[0..7]           |   |    其中发生的miss有: 
+-----------------------+-------------------+   +--&gt; A[0], B[0], A[1]与B[1]的相互取代. 
|...                    |                   |   |    总的miss次数为4.
+-----------------------+-------------------+   |
|after B[7][1]=tmp      | A[1] B[0] B[2..]  |---+
+-----------------------+-------------------+        之后的三至七行与第二行类似,
|...                    |                   |------&gt; miss的次数都是4.
+-----------------------+-------------------+
|after tmp=A[7][7]      | A[7] B[0..6]      |---+    最后一行A[7]被A[8]取代后,
+-----------------------+-------------------+   +--&gt; 不需要重新加载.
|after B[7][7]=tmp      | B[0..7]           |---+    总的miss数为3. 
+-----------------------+-------------------+

所以对角块上的总的miss次数是10+4*6+3=37.

</code></pre>

<p>对角分块有4个，普通的分块12个，所以总的miss数是<code>4*37+16*12=340</code>，和实际结果相差<code>3</code>。<code>3</code>是一个固定的偏差，程序可能在这个过程中有三次额外的内存访问，在后面的根据算法定量分析结果和实际结果中都会有<code>3</code>次miss的偏差。</p>
<h3 id="_6">缓存分块</h3>
<h4 id="_7">实现</h4>
<p>上面那种普通分块的实现会在对角块上产生太多的冲突，<code>Ａ</code>，<code>Ｂ</code>矩阵的缓存块相互替换的情况太多。我们可以考虑使用本地变量存下<code>Ａ</code>的一行后，再复制给<code>Ｂ</code>，即用本地变量作为缓存存储每个缓存块中的内容。本地变量数目不多的时候是放在寄存器上的，因此可以减少访问内存。</p>
<pre><code class="C">for (i = 0; i &lt; 32; i += 8) {
    for (j = 0; j &lt; 32; j += 8) {
        for (k = i; k &lt; i + 8; k++) {
            a0 = A[k][j];
            a1 = A[k][j + 1];
            a2 = A[k][j + 2];
            a3 = A[k][j + 3];
            a4 = A[k][j + 4];
            a5 = A[k][j + 5];
            a6 = A[k][j + 6];
            a7 = A[k][j + 7];
            B[j][k] = a0;
            B[j + 1][k] = a1;
            B[j + 2][k] = a2;
            B[j + 3][k] = a3;
            B[j + 4][k] = a4;
            B[j + 5][k] = a5;
            B[j + 6][k] = a6;
            B[j + 7][k] = a7;
        }
    }
}
</code></pre>

<h4 id="_8">结果分析</h4>
<p>同样我们先来分析一下miss的次数。非对角线的分块没有<code>A</code>， <code>B</code>之间的冲突，miss次数是<code>16</code>。</p>
<p>对于对角线上的分块，复制<code>A[m]</code>时会取代<code>B[m]</code>(第一行除外)，将数据写入<code>B[m]</code>的时候又会重新加载一次。所以，额外的miss次数为<code>7</code>次。对角块总的<code>miss</code>次数为<code>23</code>次。</p>
<p>总的miss次数应该为<code>23*4+16*12=284</code>次。</p>
<p>测试一下：</p>
<pre><code class="bash">$ ./test-trans -M32 -N32
Function 0 (4 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:1766, misses:287, evictions:255
</code></pre>

<p>实际的miss次数为<code>287</code>，和我们分析的刚好相差<code>3</code>次。</p>
<h3 id="_9">对角线优先复制</h3>
<h4 id="_10">实现</h4>
<p>这个思路来自于别人的一篇博客<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>。思路大概是这样：<code>A</code>矩阵按列优先读，<code>B</code>矩阵按照行优先写，优先处理每个分块对角线上的元素。对于<code>B[m]</code>行，因为把它加载到缓存中会取代<code>A[m]</code>, 而<code>A[m]</code>中需要复制到<code>B[m]</code>中的是<code>A[m][m]</code>。我们通过可以优先复制<code>A[m][m]</code>来避免<code>A</code>，<code>B</code>之间的这次冲突。</p>
<p>这个思路通过改变数据复制的顺序，巧妙地减少了两个矩阵之间的缓存冲突。</p>
<pre><code>for (i = 0; i &lt; N; i += 8)
    for (j = 0; j &lt; M; j += 8)
        for (k = 0; k &lt; 8; k++) {
            for (s = k; s &lt; 8; s++) 
                B[k + j][s + i] = A[i + s][j + k];
            for (s = k - 1; s &gt;= 0; s--) 
                B[k + j][s + i] = A[i + s][j + k];
        }
</code></pre>

<h4 id="_11">结果分析</h4>
<p>复制<code>B[m]</code>行的时候，<code>A[m]</code>被替换，下一行复制的时候又需要将<code>A[m]</code>加载到缓存中。所以miss的次数和上面的实现一样，<code>284</code>次。</p>
<p>测试结果：</p>
<pre><code class="bash">$ ./test-trans -M32 -N32
Function 3 (4 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 3 (diagonal first): hits:1766, misses:287, evictions:255
</code></pre>

<p>实际miss次数为<code>287</code>，和分析结果相差<code>3</code>。</p>
<h3 id="_12">先复制后转置</h3>
<h4 id="_13">实现</h4>
<p>前面提到的思路里, 在对角线的分块处都无可避免的会产生<code>A</code>, <code>B</code>矩阵之间的缓存冲突。这个冲突真的不可避免吗？答案是否定的。实验要求上写了不能改变<code>A</code>矩阵，但是<code>B</code>可以随意处理。我们可以考虑在<code>B</code>矩阵上想点办法来消除两个矩阵之间的冲突。</p>
<p>前面提到的两个实现中对角线分块的冲突产生的原因是<code>A</code>，<code>B</code>矩阵访问的顺序不同，一个按列访问，一个按行访问，导致的。交叉的访问顺序无可避免地会导致缓存<code>index</code>相同的块替换。</p>
<p>为了消除两个矩阵之间的缓存冲突，在把<code>A</code>中分块的内容复制到<code>B</code>的时候，我们按照都行优先访问顺序访问两个矩阵。这样的结果是，对应分块的内容相同，没有转置。我们在分块复制完成后，再在<code>B</code>分块里面完成转置。</p>
<pre><code class="C">const int len = 8;
for (i = 0; i &lt; N; i += len) {
    for (j = 0; j &lt; N; j += len) {
        // copy
        for (k = i, s = j; k &lt; i + len; k++, s++) {
            a0 = A[k][j];
            a1 = A[k][j + 1];
            a2 = A[k][j + 2];
            a3 = A[k][j + 3];
            a4 = A[k][j + 4];
            a5 = A[k][j + 5];
            a6 = A[k][j + 6];
            a7 = A[k][j + 7];
            B[s][i] = a0;
            B[s][i + 1] = a1;
            B[s][i + 2] = a2;
            B[s][i + 3] = a3;
            B[s][i + 4] = a4;
            B[s][i + 5] = a5;
            B[s][i + 6] = a6;
            B[s][i + 7] = a7;
        }
        // transpose
        for (k = 0; k &lt; len; k++) {
            for (s = k + 1; s &lt; len; s++) {
                a0 = B[k + j][s + i];
                B[k + j][s + i] = B[s + j][k + i];
                B[s + j][k + i] = a0;
            }
        }
    }
}
</code></pre>

<p>为了消除对角线上分块行的相互替换，在上面的实现中，每次先用本地变量缓存<code>A</code>分块的一行，再复制到B分块对应的行中。在复制完成后，<code>B</code>的分块全部在缓存中，转置过程没有miss。</p>
<h4 id="_14">结果分析</h4>
<p>这个方法消除了所有的两个矩阵之间的缓存冲突，所以miss的次数是<code>16*16=256</code>。</p>
<p>测试结果：</p>
<pre><code class="bash">$ ./test-trans -M32 -N32
Function 2 (4 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 2 (copy and then trans): hits:3586, misses:259, evictions:227
</code></pre>

<p>这大概是能够达到的最好的结果了。</p>
<h2 id="64-x-64">64 x 64</h2>
<p><code>64 x 64</code>的矩阵每个行需要8个缓存块，每四行缓存<code>index</code>会重复一次。</p>
<pre><code>    矩阵中缓存`index`分布
    +--+--+--+--+--+--+--+--+
 0  | 0| 1| 2| 3| 4| 5| 6| 7|
    +--+--+--+--+--+--+--+--+
 1  | 8| 9|10|11|12|13|14|15|
    +--+--+--+--+--+--+--+--+
 2  |16|17|18|19|20|21|22|23|
    +--+--+--+--+--+--+--+--+
 3  |24|25|26|27|28|29|30|31|
    +--+--+--+--+--+--+--+--+
 4  | 0| 1| 2| 3| 4| 5| 6| 7|
    +--+--+--+--+--+--+--+--+
 5  | 8| 9|10|11|12|13|14|15|
    +--+--+--+--+--+--+--+--+
 6  |16|17|18|19|20|21|22|23|
    +--+--+--+--+--+--+--+--+
    ...
</code></pre>

<p>显然直接按照<code>8 x 8</code>的分块来做，同一个矩阵内的缓存块就会发生冲突。按照<code>4 x 4</code>分块，没能充分利用加载进入缓存内的部分，测试结果也不能达到满分的要求。为了满分，我们要充分利用上面提到的两个思路：用本地变量做缓存，先复制后转置。</p>
<h3 id="_15">实现</h3>
<p>我的这个实现有些复杂，我尽量讲清楚我的具体步骤。</p>
<p>同样，我们保持分块为<code>8 x 8</code>，在大的分块下再分成4个<code>4 x 4</code>的小分块。我们先将<code>A</code>的前四行全部复制到<code>B</code>的前四行，这个时候<code>B</code>的左上角的元素在最终正确的位置，<code>B</code>的右上角元素是应该放到左下角的元素。然后，我们在复制后<code>A</code>的后四行到<code>B</code>的过程中，利用本地变量将<code>B</code>右上角的内容复制到左下角。</p>
<p>具体步骤如下：</p>
<p><img alt="" src="pictures/csapp-cachelab-1.jpg" /></p>
<ol>
<li>先将<code>A</code>的前四行按照(1)复制到<code>B</code>中。</li>
<li>按照(2)将<code>A</code>中对应位置的元素存到本地变量中。</li>
</ol>
<p><img alt="" src="pictures/csapp-cachelab-2.jpg" /></p>
<ol>
<li><code>buf1</code>的四个元素与<code>B</code>右上角的第一行交换，将<code>buf2</code>中的值存到<code>B</code>右下角的对应位置。此时缓存中<code>B[4]</code>替换<code>B[0]</code>。</li>
<li>将<code>buf1</code>中的元素存放到<code>B</code>左下角对应位置。</li>
<li>改变位置，重复(2)，(3)，(4)，直到所有元素到达正确位置。</li>
</ol>
<p>整个过程比较复杂，不过根据图应该可以看懂。下面是代码的实现：</p>
<pre><code class="C">for (i = 0; i &lt; N; i += block_size) {
    for (j = 0; j &lt; M; j += block_size) {
        for (k = 0; k &lt; block_size / 2; k++) {
            // A top left
            a0 = A[k + i][j];
            a1 = A[k + i][j + 1];
            a2 = A[k + i][j + 2];
            a3 = A[k + i][j + 3];

            // copy
            // A top right
            a4 = A[k + i][j + 4];
            a5 = A[k + i][j + 5];
            a6 = A[k + i][j + 6];
            a7 = A[k + i][j + 7];

            // B top left
            B[j][k + i] = a0;
            B[j + 1][k + i] = a1;
            B[j + 2][k + i] = a2;
            B[j + 3][k + i] = a3;

            // copy
            // B top right
            B[j + 0][k + 4 + i] = a4;
            B[j + 1][k + 4 + i] = a5;
            B[j + 2][k + 4 + i] = a6;
            B[j + 3][k + 4 + i] = a7;
        }
        for (k = 0; k &lt; block_size / 2; k++) {
            // step 1 2
            a0 = A[i + 4][j + k], a4 = A[i + 4][j + k + 4];
            a1 = A[i + 5][j + k], a5 = A[i + 5][j + k + 4];
            a2 = A[i + 6][j + k], a6 = A[i + 6][j + k + 4];
            a3 = A[i + 7][j + k], a7 = A[i + 7][j + k + 4];
            // step 3
            tmp = B[j + k][i + 4], B[j + k][i + 4] = a0, a0 = tmp;
            tmp = B[j + k][i + 5], B[j + k][i + 5] = a1, a1 = tmp;
            tmp = B[j + k][i + 6], B[j + k][i + 6] = a2, a2 = tmp;
            tmp = B[j + k][i + 7], B[j + k][i + 7] = a3, a3 = tmp;
            // step 4
            B[j + k + 4][i + 0] = a0, B[j + k + 4][i + 4 + 0] = a4;
            B[j + k + 4][i + 1] = a1, B[j + k + 4][i + 4 + 1] = a5;
            B[j + k + 4][i + 2] = a2, B[j + k + 4][i + 4 + 2] = a6;
            B[j + k + 4][i + 3] = a3, B[j + k + 4][i + 4 + 3] = a7;
        }
    }
}
</code></pre>

<h3 id="_16">结果分析</h3>
<p>这个实现会完全消除行同一个矩阵内部的冲突，但是两个矩阵之间的冲突没能完全避免。</p>
<p>对于在对角线上的块，步骤(1)会有3次额外miss，步骤(2)、(3)、(4)、(5)有7次额外miss。普通块miss次数仍然为8。</p>
<p>总的miss次数为<code>(3+7)*8 + 64*8*2=1104</code>。</p>
<pre><code class="bash">$ ./test-trans -M64 -N64

Function 0 (4 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:9138, misses:1107, evictions:1075
</code></pre>

<p>(1)中的三次miss可以通过先复制后转置的思路消除，可以减少<code>3*8=24</code>次miss。</p>
<pre><code class="bash">./test-trans -M64 -N64

Function 1 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 1 (64x64): hits:12234, misses:1083, evictions:1051

</code></pre>

<p>这个结果还不错，比<code>1300</code>的要求小了不少。</p>
<h2 id="61-x-67">61 x 67</h2>
<p>这个矩阵中缓存块的分布比较奇怪，我根据观察缓存块的分布将分块的大小设置为<code>8 x 23</code>。</p>
<pre><code class="C">for (i = 0; i &lt; N; i += 8) {
    for (j = 0; j &lt; M; j += 23) {
        if (i + 8 &lt;= N &amp;&amp; j + 23 &lt;= M) {
            for (s = j; s &lt; j + 23; s++) {
                a0 = A[i][s];
                a1 = A[i + 1][s];
                a2 = A[i + 2][s];
                a3 = A[i + 3][s];
                a4 = A[i + 4][s];
                a5 = A[i + 5][s];
                a6 = A[i + 6][s];
                a7 = A[i + 7][s];
                B[s][i + 0] = a0;
                B[s][i + 1] = a1;
                B[s][i + 2] = a2;
                B[s][i + 3] = a3;
                B[s][i + 4] = a4;
                B[s][i + 5] = a5;
                B[s][i + 6] = a6;
                B[s][i + 7] = a7;
            }
        } else {
            for (k = i; k &lt; min(i + 8, N); k++) {
                for (s = j; s &lt; min(j + 23, M); s++) {
                    B[s][k] = A[k][s];
                }
            }
        }
    }
}
</code></pre>

<p>测试结果：</p>
<pre><code class="bash">./test-trans -M61 -N67

Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:6316, misses:1863, evictions:1831
</code></pre>

<p>因为2000的miss要求比较低，所以很容易就过了。</p>
<h2 id="_17">总结</h2>
<p>总的来说，这个实验收获还是很多的。尤其是对miss次数的定量分析，让我很受益。之前学习算法之类的，只会大概估计一下复杂度的等级，完全定量地对程序分析对我来说还是比较少。在其他方面，如怎样写出对缓存友好的代码，也有不少收获。</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="https://blog.codedragon.tech/2017/09/25/深入理解计算机系统CacheLab-PartB实验报告/">深入理解计算机系统CacheLab-PartB实验报告</a>&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
    


    </div>

    <!-- 
    <div class="footer">
    
    &copy; Copyright  by <a href=https://yangtau.me>τ</a>.
    
    </div>
    -->

</body>



<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },    
      "HTML-CSS": { availableFonts: ["TeX"] }
    });
</script>


</html>